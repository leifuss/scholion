#!/usr/bin/env python3
"""
Incremental Zotero → inventory.json sync.

Connects to the Zotero web API, fetches all items in the configured
collection, and merges them into the existing data/inventory.json:

  - NEW items   → added with metadata from Zotero (pdf_status = 'url_only')
  - EXISTING    → Zotero-sourced fields (title, authors, tags, etc.) updated;
                   pipeline-generated fields (extracted, quality_score, etc.) preserved
  - REMOVED     → items in inventory.json but no longer in Zotero are left untouched
                   (they may have extraction results we want to keep)

Designed to run headlessly in GitHub Actions (no local Zotero desktop needed).

Usage:
  python scripts/zotero_sync.py                  # sync, commit if changed
  python scripts/zotero_sync.py --dry-run        # show changes without writing
  python scripts/zotero_sync.py --trigger-extract # output new keys for downstream workflow
"""

import sys
import os
import json
import re
import argparse
import logging
from pathlib import Path

logging.basicConfig(level=logging.INFO, format='%(levelname)s %(message)s')
log = logging.getLogger(__name__)

_ROOT = Path(__file__).parent.parent

try:
    from dotenv import load_dotenv
    load_dotenv(_ROOT / '.env', override=True)
    load_dotenv(_ROOT / 'data' / '.env', override=True)
except ImportError:
    pass

sys.path.insert(0, str(_ROOT / 'src'))


# ── HTML stripping (for Zotero notes) ────────────────────────────────────────

def _strip_html(html: str) -> str:
    text = re.sub(r'<[^>]+>', ' ', html or '')
    for ent, ch in [('&amp;', '&'), ('&lt;', '<'), ('&gt;', '>'),
                    ('&nbsp;', ' '), ('&#160;', ' '), ('&quot;', '"'), ('&#39;', "'")]:
        text = text.replace(ent, ch)
    return re.sub(r'\s+', ' ', text).strip()


# ── Fields sourced from Zotero (updated on every sync) ───────────────────────
_ZOTERO_FIELDS = {
    'title', 'year', 'authors', 'item_type', 'place', 'publisher',
    'abstract', 'pub_title', 'pages', 'url', 'tags', 'notes',
}

# ── Fields generated by the pipeline (never overwritten by sync) ─────────────
_PIPELINE_FIELDS = {
    'pdf_status', 'pdf_path', 'doc_type', 'page_count', 'avg_chars_pg',
    'language', 'extracted', 'quality_score', 'recommendation',
    'has_reader', 'text_quality', 'chars_per_page',
}


def _item_to_entry(item: dict) -> dict:
    """Convert a raw pyzotero item dict to an inventory entry."""
    data = item.get('data', {})

    creators = data.get('creators', [])
    authors = '; '.join(
        c.get('lastName', c.get('name', ''))
        for c in creators
        if c.get('creatorType') in ('author', 'editor')
    )[:80]

    date = data.get('date', '')
    year = date[:4] if date else ''

    pub_title = (
        data.get('bookTitle', '')          or
        data.get('publicationTitle', '')   or
        data.get('proceedingsTitle', '')   or
        data.get('encyclopediaTitle', '')  or
        data.get('university', '')         or
        data.get('institution', '')        or
        ''
    )

    tags = [t.get('tag', '') for t in data.get('tags', []) if t.get('tag')]

    return {
        'key':          item.get('key', ''),
        'title':        data.get('title', 'Untitled'),
        'year':         year,
        'authors':      authors,
        'item_type':    data.get('itemType', ''),
        'place':        data.get('place', ''),
        'publisher':    data.get('publisher', ''),
        'abstract':     data.get('abstractNote', '') or None,
        'pub_title':    pub_title or None,
        'pages':        data.get('pages', '') or None,
        'url':          data.get('url', ''),
        'tags':         tags,
        'notes':        [],
        # Pipeline defaults for new items
        'pdf_status':   'url_only' if data.get('url') else 'no_attachment',
        'pdf_path':     None,
        'doc_type':     'unknown',
        'page_count':   None,
        'avg_chars_pg': None,
        'language':     None,
        'extracted':    False,
        'quality_score': None,
        'recommendation': '',
    }


def sync(dry_run: bool = False) -> dict:
    """
    Sync Zotero library → inventory.json.

    Returns:
        {'added': [key, ...], 'updated': [key, ...], 'unchanged': int}
    """
    from zotero_client import ZoteroLibrary

    library = ZoteroLibrary()
    log.info(f"Connecting to Zotero ({library.library_type} library, ID {library.library_id})…")
    if library.collection_name:
        log.info(f"  Collection filter: {library.collection_name!r}")

    # Fetch parents and children in one paginated call (avoids N+1 requests)
    items, children_by_parent = library.get_all_items_with_children()
    log.info(f"  {len(items)} items in Zotero ({sum(len(v) for v in children_by_parent.values())} child objects)")

    # Extract notes from the already-fetched children
    notes_by_key = {}
    for parent_key, children in children_by_parent.items():
        item_notes = []
        for child in children:
            if child['data'].get('itemType') == 'note':
                note_text = _strip_html(child['data'].get('note', ''))
                if note_text:
                    item_notes.append(note_text)
        if item_notes:
            notes_by_key[parent_key] = item_notes

    # Load existing inventory
    inv_path = _ROOT / 'data' / 'inventory.json'
    if inv_path.exists():
        existing = json.loads(inv_path.read_text(encoding='utf-8'))
    else:
        existing = []
    existing_by_key = {e['key']: e for e in existing}

    added = []
    updated = []
    unchanged = 0

    # Process Zotero items
    zotero_entries = {}
    for item in items:
        data = item.get('data', {})
        # Skip attachment and note items
        if data.get('itemType') in ('attachment', 'note', 'linkMode'):
            continue

        entry = _item_to_entry(item)
        key = entry['key']
        if not key:
            continue

        # Add notes
        entry['notes'] = notes_by_key.get(key, [])

        zotero_entries[key] = entry

        if key in existing_by_key:
            # Merge: update Zotero fields, preserve pipeline fields
            old = existing_by_key[key]
            merged = dict(old)
            changed = False
            for field in _ZOTERO_FIELDS:
                new_val = entry.get(field)
                old_val = old.get(field)
                if new_val != old_val:
                    merged[field] = new_val
                    changed = True
            if changed:
                existing_by_key[key] = merged
                updated.append(key)
            else:
                unchanged += 1
        else:
            # Brand-new item
            existing_by_key[key] = entry
            added.append(key)

    # Rebuild inventory list preserving original order, appending new items
    seen = set()
    result = []
    for e in existing:
        if e['key'] in existing_by_key:
            result.append(existing_by_key[e['key']])
            seen.add(e['key'])
    # Append new items (in Zotero order)
    for item in items:
        key = item.get('key', '')
        if key and key not in seen and key in existing_by_key:
            result.append(existing_by_key[key])
            seen.add(key)

    summary = {'added': added, 'updated': updated, 'unchanged': unchanged}

    log.info(f"\nSync result:")
    log.info(f"  New items:     {len(added)}")
    log.info(f"  Updated:       {len(updated)}")
    log.info(f"  Unchanged:     {unchanged}")
    log.info(f"  Total:         {len(result)}")

    if added:
        log.info(f"\nNew items:")
        for key in added:
            title = existing_by_key[key].get('title', '')[:60]
            log.info(f"  + [{key}] {title}")

    if not dry_run and (added or updated):
        inv_path.write_text(
            json.dumps(result, indent=2, ensure_ascii=False),
            encoding='utf-8',
        )
        log.info(f"\n  Saved {inv_path}")

    return summary


def main():
    parser = argparse.ArgumentParser(description='Sync Zotero library → inventory.json')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show changes without writing')
    parser.add_argument('--trigger-extract', action='store_true',
                        help='Write new keys to GITHUB_OUTPUT for downstream workflow')
    args = parser.parse_args()

    result = sync(dry_run=args.dry_run)

    # Write new keys to GITHUB_OUTPUT for workflow chaining
    if args.trigger_extract and result['added']:
        output_file = os.environ.get('GITHUB_OUTPUT')
        keys_str = ' '.join(result['added'])
        if output_file:
            with open(output_file, 'a') as f:
                f.write(f"new_keys={keys_str}\n")
                f.write(f"has_new=true\n")
            log.info(f"  Wrote {len(result['added'])} new key(s) to GITHUB_OUTPUT")
        else:
            # Not in GitHub Actions — just print
            print(f"\nNEW_KEYS={keys_str}")

    if not result['added'] and not result['updated']:
        log.info("\nNo changes — inventory is up to date with Zotero.")


if __name__ == '__main__':
    main()
